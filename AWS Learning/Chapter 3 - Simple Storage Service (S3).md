- ## S3 Security
	- private by default
	- the only identity that has access to the bucket is the Account ROOT user of the account that created that bucket
	
	- ### S3 Bucket policy
		- a form of **Resource Policy**
		- Like **identity policies, but attached to a bucket**
		- **Allow / Deny same or different accounts**
		- **Allow / Deny Anonymous principals**
		- Resource policies **have a specific field** (Principal: "*")
		- Bucket policies have conditions (through the Condition field)
			- ![[Pasted image 20240302194517.png]]***e.g. Allow access to bucket to all principals except the IP Address 1.3.3.7/32***
			
	- ### Access Control Lists (ACLs)
		- ACLs can be put on objects and bucket
		- Legacy stuff, not recommended by AWS
		- A subresource
		- Inflexible and simple permissions (*READ, WRITE, READ_ACP, WRITE_ACP, FULL_CONTROL*)
		
	- ### Block Public Access Settings
		- These apply to all public access, not intra cloud IAM identities!!!

- ## S3 Static Hosting
	
	- Allows access via **HTTP**
	- **Index** and **Error** documents are set to specific objects in S3
	- Website endpoint is created
	- Custom Domain via **R53** - **BUCKETNAME MATTERS**

- ## Object Versioning & MFA Delete
	
	- ### Object versioning
		- **disabled by default**
		- **once enabled it can't be disabled**
		- an alternative is to **suspend** the bucket (if desired it can be re-enabled)
		
		- it lets you store **multiple versions of an object** in the **same bucket**
		- if you modify the object, it **generates a new version of that object**, leaving the original one in place
		- when the versioning is disabled the **ID** of the object is set to **NULL**
		- the **greatest ID value represents the latest / current version** (returned by default)
		
		- versioning also impacts **deletions**
		- if we want to delete an object and **we do not specify any ID**, the bucket will assume that we want to delete the **latest object version, along with all the previous versions**
		- the deletion is **not actually happening**, but a new version of that object, called a **DELETE MARKER**, is created, and it makes **all the versions under it look hidden**
		- If we delete the **DELETE MARKER the files are visible again**
		- In order to actually delete an object we have to specify the version ID
		- When the latest object is deleted, the previous version becomes the latest/current one
		- **!!!! STORAGE IS CONSUMED / BILLED FOR ALL VERSIONS OF THE OBJECT**
		- Only way to 0 costs is to delete the bucket
		
	- ### MFA Delete
		- **enabled in versioning config**
		- is required to **change bucket versioning state**
		- is required to **delete versions**
		- **in order to delete a version of an object we need to provide the serial number (MFA) + the Code Passed with API Calls**
		
- ## S3 Performance Optimisation
		
     ### One Stream
		
	-  By default, when you upload an object to S3 it is uploaded as **a huge blob in a single data stream**. The file becomes an object that will be uploaded using the PUT API. 
		- **This means that if the stream fails, the whole upload fails and requires full restart.**
		- Limit to 5GB
		
	 ### Multipart Upload
		
		- Data is broken into multiple parts
		- Min data size for multipart is **100MB**
		- 10000 max parts, 5MB to 5GB
		- Last part can be smaller than 5MB
		- Parts can fail, and be restarted
		- Transfer rate = speeds of all parts
		
     ### Accelerated Transfer
		
	- Using the network of AWS Edge Locations (to overcome long inefficient routings of data through the public internet )
	- Not always convenient **( in case there are a small number of hops )**

- ## Key Management Store (KMS)
	
	- Used by multiple AWS products
	- **Regional and Public** service (***stored in a region and never leave***)
	- Can create **Multi-region keys** if needed
	- **Create, Store and Manage Keys**
	- **Symmetric and Asymmetric** Keys
	- Cryptographic operations (encrypt, decrypt)
	- **Keys never leave KMS** - Provides Standard **FIPS 140-2 (L2)** <- Level 2 Compliance
	- **Policies are different for encryption and decryption**
	- **Supports Key Rotation**
	- *supports Aliases (also per region)*
	
	KMS Keys are a **container** for the logical key.
	**KMS Keys are logical - ID, Date, Policy, description and state**
	They can be **GENERATED or IMPORTED**, and can have up to **4KB of data**
	
	- ### How KMS works?
	
		1. Create a Key in KMS
		2. Encrypt data by sending it to KMS and specifying what key should be used
		3. Decrypt *(no need to specify the key - it is already specified in the cypher text of the data)*
		![[Screenshot 2024-03-05 at 01.44.19.png]]
	
	- ### Data Encryption Keys (DEKs)
		
		- generated by KMS
		- GenerateDataKey - works on data > 4KB
		- **not stored** in the KMS service - creates it and then discards it
		- *The KMS only creates the DEKs but does not use them for encryption - you do, or the service using the DEK*
		- **S3 can use KMS to encrypt every single object**
	
	     ### How do DEKs Work?
		
		1. Creates 2 keys *immediately before* you want to encrypt something : 
			1. **Plaintext Version**
			2. A Cypher text Version of that same encryption Key - ***encrypted using the KMS Key that generated it***
		2. Encrypt Data using plaintext key
		3. **Discard** plaintext key
		4. **Store** encrypted key **with the encrypted data**
		5. *For decryption* -> Pass the cypher text key to KMS to ***decrypt it using the same KMS key used to generate it***
		6. **Use the resulting key to decrypt the data**
		7. **Discard** the cypher text encryption key
		
	 ### Key policies and Security
		
	- **The account that created the key is immediately granted access to that key**
	- Key policies are ***Resource Policies***
	- Every key has one - ***for customer managed keys (created or imported manually by the user) we have to implement it, the self account trust is not automatic***
	- Better use **IAM Policies**
	- Supports **Grants**

- ## CSE/SSE Object Encryption
	- 