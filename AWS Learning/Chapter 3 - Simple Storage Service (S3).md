- ## S3 Security
	- private by default
	- the only identity that has access to the bucket is the Account ROOT user of the account that created that bucket
	
	- ### S3 Bucket policy
		- a form of **Resource Policy**
		- Like **identity policies, but attached to a bucket**
		- **Allow / Deny same or different accounts**
		- **Allow / Deny Anonymous principals**
		- Resource policies **have a specific field** (Principal: "*")
		- Bucket policies have conditions (through the Condition field)
			- ![[Pasted image 20240302194517.png]]***e.g. Allow access to bucket to all principals except the IP Address 1.3.3.7/32***
		
	- ### Access Control Lists (ACLs)
		- ACLs can be put on objects and bucket
		- Legacy stuff, not recommended by AWS
		- A subresource
		- Inflexible and simple permissions (*READ, WRITE, READ_ACP, WRITE_ACP, FULL_CONTROL*)
		
	- ### Block Public Access Settings
		- These apply to all public access, not intra cloud IAM identities!!!

- ## S3 Static Hosting
	
	- Allows access via **HTTP**
	- **Index** and **Error** documents are set to specific objects in S3
	- Website endpoint is created
	- Custom Domain via **R53** - **BUCKETNAME MATTERS**

- ## Object Versioning & MFA Delete
	
	- ### Object versioning
		- **disabled by default**
		- **once enabled it can't be disabled**
		- an alternative is to **suspend** the bucket (if desired it can be re-enabled)
		
		- it lets you store **multiple versions of an object** in the **same bucket**
		- if you modify the object, it **generates a new version of that object**, leaving the original one in place
		- when the versioning is disabled the **ID** of the object is set to **NULL**
		- the **greatest ID value represents the latest / current version** (returned by default)
		
		- versioning also impacts **deletions**
		- if we want to delete an object and **we do not specify any ID**, the bucket will assume that we want to delete the **latest object version, along with all the previous versions**
		- the deletion is **not actually happening**, but a new version of that object, called a **DELETE MARKER**, is created, and it makes **all the versions under it look hidden**
		- If we delete the **DELETE MARKER the files are visible again**
		- In order to actually delete an object we have to specify the version ID
		- When the latest object is deleted, the previous version becomes the latest/current one
		- **!!!! STORAGE IS CONSUMED / BILLED FOR ALL VERSIONS OF THE OBJECT**
		- Only way to 0 costs is to delete the bucket
		
	- ### MFA Delete
		- **enabled in versioning config**
		- is required to **change bucket versioning state**
		- is required to **delete versions**
		- **in order to delete a version of an object we need to provide the serial number (MFA) + the Code Passed with API Calls**
		
- ## S3 Performance Optimisation
		
     ### One Stream
		
	-  By default, when you upload an object to S3 it is uploaded as **a huge blob in a single data stream**. The file becomes an object that will be uploaded using the PUT API. 
		- **This means that if the stream fails, the whole upload fails and requires full restart.**
		- Limit to 5GB
		
	 ### Multipart Upload
		
		- Data is broken into multiple parts
		- Min data size for multipart is **100MB**
		- 10000 max parts, 5MB to 5GB
		- Last part can be smaller than 5MB
		- Parts can fail, and be restarted
		- Transfer rate = speeds of all parts
		
     ### Accelerated Transfer
		
	- Using the network of AWS Edge Locations (to overcome long inefficient routings of data through the public internet )
	- Not always convenient **( in case there are a small number of hops )**

- ## Key Management Store (KMS)
	
	- Used by multiple AWS products
	- **Regional and Public** service (***stored in a region and never leave***)
	- Can create **Multi-region keys** if needed
	- **Create, Store and Manage Keys**
	- **Symmetric and Asymmetric** Keys
	- Cryptographic operations (encrypt, decrypt)
	- **Keys never leave KMS** - Provides Standard **FIPS 140-2 (L2)** <- Level 2 Compliance
	- **Policies are different for encryption and decryption**
	- **Supports Key Rotation**
	- *supports Aliases (also per region)*
	
	KMS Keys are a **container** for the logical key.
	**KMS Keys are logical - ID, Date, Policy, description and state**
	They can be **GENERATED or IMPORTED**, and can have up to **4KB of data**
	
	- ### How KMS works?
	
		1. Create a Key in KMS
		2. Encrypt data by sending it to KMS and specifying what key should be used
		3. Decrypt *(no need to specify the key - it is already specified in the cypher text of the data)*
		![[Screenshot 2024-03-05 at 01.44.19.png]]
	
	- ### Data Encryption Keys (DEKs)
		
		- generated by KMS
		- GenerateDataKey - works on data > 4KB
		- **not stored** in the KMS service - creates it and then discards it
		- *The KMS only creates the DEKs but does not use them for encryption - you do, or the service using the DEK*
		- **S3 can use KMS to encrypt every single object**
	
	     ### How do DEKs Work?
		
		1. Creates 2 keys *immediately before* you want to encrypt something : 
			1. **Plaintext Version**
			2. A Cypher text Version of that same encryption Key - ***encrypted using the KMS Key that generated it***
		2. Encrypt Data using plaintext key
		3. **Discard** plaintext key
		4. **Store** encrypted key **with the encrypted data**
		5. *For decryption* -> Pass the cypher text key to KMS to ***decrypt it using the same KMS key used to generate it***
		6. **Use the resulting key to decrypt the data**
		7. **Discard** the cypher text encryption key
		
	 ### Key policies and Security
		
	- **The account that created the key is immediately granted access to that key**
	- Key policies are ***Resource Policies***
	- Every key has one - ***for customer managed keys (created or imported manually by the user) we have to implement it, the self account trust is not automatic***
	- Better use **IAM Policies**
	- Supports **Grants**

- ## Object Encryption
	
	**Buckets are not encrypted! Objects are!!!**
	
	- ### Client Side Encryption (CSE)
		
		- data is encrypted before it's sent to the server
		- The user is responsible for recording which key is used for each object
		- The user controls the keys, process and tooling for encryption
		
	- ### Server Side Encryption (SSE)
		
		- The data is transmitted as plaintext.
		- Once it has arrived at the s3 endpoint, it is encrypted and stored into S3
		
		- #### Three types of SSE:
			1. **SSE-C (Server Side Encryption with customer provided keys)**
				
				- *The Object is sent as plaintext together with a key but it's encrypted in transit by the https, so the data is not visible.*
				- *In order to decrypt, we need to provide a request and the key (which will be discarded after decryption*
				- **Good for Heavy Regulation Environments**
				- ***Save on CPU compared to CSE (The encryption and decryption is done server-side)***
				- ![[Screenshot 2024-03-08 at 15.26.28.png]]
			
			2. **SSE-S3 (Server Side Encryption with AWS S3 Provided Keys) - *default***
				
				- AWS Handles both the encryption processes as well as the key generation
				- When we upload an object, AWS generates a key just for that object (per object key), and encrypts the object before storing it
				- Another key called an S3 key (invisible to the customer) is created, and it is used to encrypt the per object keys
				- **We are left with an cipher object and a cipher key** *(AES256)*
				- **Very Little Control (no access or rotation control of the keys)**
				- ![[Screenshot 2024-03-08 at 15.39.11.png]]
				
			3. **SSE-KMS (Server Side Encryption with KMS Keys stored in KMS Key Management Service)**
				
				- The power of this method comes from creating a **Customer Managed KMS Key** - managed by you and supports separated permissions
				- When we want to store an object into S3, the S3 Service makes a request to the existing KMS key and a Data Encryption Key is created
				- The DEKs are in 2 versions ( **one plain text and one cipher text**)
				- After the object is encrypted using the plain text key, it is discarded and only the cipher text key is stored with the object. (same architecture like per object keys, but these can be managed)
				- Provides control over KMS usage, rotation, logging, audit and **Role Separation**
				- **With No Access to KMS a person can't decrypt the encrypted key -> No decryption of the data**
				- ![[Screenshot 2024-03-08 at 15.48.56.png]]
				
	 ![[Screenshot 2024-03-08 at 15.51.21.png]]

- ## S3 Bucket Keys
	
	- In a scenario where **no Bucket keys** are used, **for every Object** that we want to store in S3 with encryption, we need a unique DEK (Data Encryption Key). ***Each DEK means an API Call to the KMS (take the kms key and generate the DEK)***.
	- Using a single KMS Key limits the number of PUTS that can be done to store encrypted objects / second / key
	- ![[Screenshot 2024-03-08 at 16.59.48.png]]
	
	
	- If we use ***The Bucket Keys***, the KMS Key is used to create a **time limited S3 Bucket Key** *(which will be used further to generate DEKs)* -> Offloads the work from KMS to S3 and improves scalability
	- ![[Screenshot 2024-03-08 at 17.02.00.png]]
	
	
	- **!!! After enabling Bucket Keys, in the CloudTrail KMS Logs we will se the bucket name, not the objects ---- due to the S3Bucket Key being used to generate the DEKs, not the KMS !!!**
	- Works with replication
	- When replicating plaintext to a bucket using bucket keys, the encryption is done at the destination (for more details visit [https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucket-key.html](https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucket-key.html))

- ## S3 Object Storage Classes
	
	- 








